# Обробка і створення помилок. Асинхронне програмування: callback, Promise, async/await.

Зміст:
1. Обробка помилок
1. Створення помилок
1. Типи помилок
1. Callback
1. Promise
1. Async та await


#
## Обробка помилок

У процесі роботи прогами можуть бути різні `помилки`, які порушують звичний хід програми і навіть змушують її перервати виконання. Мова `JavaScript` має інструменти для усунення таких ситуацій. Для обробки подібних ситуацій `JavaScript` надає конструкцію `try...catch...finally`.

```javascript
try {
    console.log("Before error");
    callSomeFunc(); // Виклик неіснуючої функції
    console.log("After error");
} catch (e) {
    console.log("Error:", e);
} finally {
    console.log("Finally block")
}

console.log("After try...catch...finaly");
```
Після оператора `try` визначається блок коду. Цей блок містить `інструкції`, при виконанні яких може виникнути потенційна `помилка`.

Потім іде оператор `catch`. Після цього оператора в круглих дужках вказується назва об'єкта, який міститиме інформацію про помилку. І далі йде блок `catch`. Цей блок виконується лише при виникненні помилки у блоці `try`.

Після блоку `catch` йде оператор `finally` зі своїм блоком інструкцій. Цей блок виконується в кінці після блоку try і catch незалежно від того, виникла помилка чи ні.

Варто зазначити, що лише блок `try` є обов'язковим. А один із решти блоків - `catch` або `finally` ми можемо пропустити. Однак один з цих блоків (не важливо catch або finally) обов'язково має бути присутнім.

У блоці catch ми можемо отримати інформацію про помилку, яка представляє об'єкт.

#
## Створення помилок

Інтерпретатор `JavaScript` генерує помилки для низки ситуацій, наприклад, при виклику неіснуючої функції, повторному присвоєння константі значення і т.д. Але при необхідності ми самі можемо `генерувати помилки` та визначити умови, коли генеруватиметься помилка. Помилка генерується за допомогою оператора `throw` і зупиняє виконання програми. Помилку можна генерувати також з допомою класу `Error`, котрий приведе помилку до належної форми.

```javascript
function devide(num1, num2) {
    if (num2 === 0) throw new Error("Divide by zero is not allowed");
    return num1 / num2;
}

devide(100, 0);
```

#
## Типи помилок

Ми розглянули, що помилка, що генерується `інтерпретатором`, представляє тип `Error`, проте при виклику неіснуючої функції генерується помилка типу `ReferenceError`. Справа в тому, що тип `Error` представляє загальний тип помилок. У той же час, є конкретні типи помилок для певних ситуацій:

| Назва | Опис |
|-------|------|
| `AssertionError` | вказує на помилку у assertion |
| `RangeError` | помилка генерується, якщо параметр або змінна, є числом, яке знаходиться поза деяким діапазоном |
| `ReferenceError`| помилка генерується при зверненні до неіснуючого посилання |
| `SyntaxError`| помилка синтаксису |
| `SystemError`| помилка у середовищі виконання |
| `TypeError`| помилка генерується, якщо значення змінної або параметра мають некоректний тип або спробу змінити значення, яке не можна змінювати |


#
## Callback

`JavaScript` виконується `асинхронно`. Найпростішим методом роботи  з асинкронністю у `JavaScript` є колбек. 

`Callback` - це функція котра передається у параметр іншої котра виконується асинхронно, і викликається після певних дій. Функції називають "асинхронними", тому що дія буде завершена не зараз, а потім.

```javascript
setTimeout(() => {
    console.log("Hello from callback!");
}, 1000);
```

### Колбек у колбеку

Дуже часто виникає потреба у більш складних асинхроних діях, ніж одноразовий виклик колбеку. Таким чином доводиться багато разів виклати колбек з колбеку, що у призводить до так званого `callback hell`

Приклад `callback hell`:

```javascript
app.get("/details", (req, res) => {
    const name = req.query.name;

    // Запит до бази даних з використанням кобека
    Detail.find({ name: name }, { '_id': 0, 'authorId': 1 }, (err, result) => {
        if (err) return err;

        let searchResult = result[0]["authorId"];
        let options = {
            url: `https://api.elsevier.com/content/author/author_id/${searchResult}?apiKey`,
            headers: { 'Accept': 'application/json' }
        };

        // http-запит до звонішнього ресурсу під час запиту до бази
        request(options, (error, response) => {
            if (error) return error;

            let jsonObj = JSON.parse(response);

            if (jsonObj['author-retrieval-response'] == undefined) {
                res.send("No details");
            } else {
                let reqData = jsonObj['author-retrieval-response'][0];
                let authprofile = reqData["author-profile"]
                let names = authprofile["preferred-name"]["indexed-name"]
                let citation = reqData["coredata"]["citation-count"];
                let query = { authorId: searchResult };

                // Знову запит до баи даних з колбеком
                Detail.findOneAndUpdate(query, {
                    name: names,
                    citationCount: citation
                }, (err, res) => {
                    if (err) throw err;
                    return res;
                })
                res.render("details", { data: reqData });
            }
        });
    });
});
```
Кожну нову дію ми змушені викликати всередині колбека. Цей варіант підійде, коли ми маємо одну-дві дії, але для більшої кількості вже не зручно. Існують альтернативи колбеку, це `Promise` та `async/await`.


#
## Promise

`Проміс (promise)` - це об'єкт, що становить результат успішного чи невдалого завершення асинхронної операції. Асинхронна операція, спрощено кажучи, це деяка дія, виконується незалежно від навколишнього коду, в якому вона викликається, не блокує виконання коду, що викликається.

Проміс може бути в одному з наступних станів:
| Назва | Стан | Опис |
|-------|------|------|
| `pending` | стан очікування | початковий стан, проміс створено, але виконання ще не завершено |
| `fulfilled` | успішно завершено | дія, яка представляє проміс, успішно завершена |
| `rejected` | завершено з помилкою | при виконанні дії, що представляє проміс, сталася помилка |

Для створення промісу застосовується конструктор типу `Promise`. Як параметр конструктор приймає функцію, яка виконується при створенні промісу. 

Як правило, функція, яка передається в конструктор `Promise`, приймає два параметри. Обидва ці параметри - `resolve` і `reject` також представляють функції. І кожна з цих функцій набуває параметра будь-якого типу.
Перший параметр – функція `resolve` викликається у разі успішного виконання.
Другий параметр – функція `reject` викликається, якщо виконання операції завершилося з помилкою.

```javascript
const x = 4;
const y = 2;
const promise1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        if (y === 0) {
            reject("Divide by zero is not allowed");
            return;
        }
        const z = x / y;
        resolve(z);
    }, 2000);
});
```

### Отримання результату операції в Promise

Для отримання результату операції промісу застосовується функція `then()` об'єкта `Promise`.

```javascript
function devide(x, y) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (y === 0) {
                reject("Divide by zero is not allowed");
                return;
            }
            const z = x / y;
            resolve(z);
        }, 2000);
    });
}

const result = devide(4,2);
console.log(result);

result.then((value) => {
    console.log(`Promise response: ${value}`);
});
```
Тобто параметр `value` тут представлятиме рядок "Привіт світ!", який передається в `resolve` ("Привіт світ!").

### Обробка помилок у Promise

Однією з переваг промісів є простіша обробка помилок. Для отримання та обробки помилки ми можемо використовувати функцію `catch()` об'єкта `Promise`, яка як параметр приймає функцію обробника помилки:

```javascript
function devide(x, y) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (y === 0) {
                reject("Divide by zero is not allowed");
                return;
            }
            const z = x / y;
            resolve(z);
        }, 2000);
    });
}

const result2 = devide(4,0);
console.log(result2);

result2.then((value) => {
    console.log(`Promise response: ${value}`);
}).catch((error) => {
    console.log(error);
});
```
Функція `catch()` як параметр приймає обробник помилки. Параметром цієї функції-обробника є значення, яке передається в `reject()`.

Консольний висновок:

### Створення ланцюжків промісів

Одним із переваг промісів є те, що вони дозволяють створювати `ланцюжки промісів`. Так, раніше ми розглянули застосування методів `then()` та `catch()` для отримання та обробки результатів та помилок асинхронної операції. При виконанні ці методи генерують новий об'єкт `Promise`, для якого ми можемо також викликати методи `then()` і `catch()`, і, таким чином, побудувати ланцюжок промісів. Завдяки цьому ми можемо обробляти кілька асинхронних операцій.

Для обробки помилок до ланцюжка в кінці додається метод `catch()`, який поверне об'єкт `Promise`. Розглянемо на простому прикладі.

Крім методів `then()` та `catch()` об'єкт `Promise` для обробки результату також надає метод `finally()`. Цей метод виконується в кінці ланцюжка промісів, незалежно відбулася помилка або виконання промісу пройшло успішно.

```javascript
new Promise(resolve => resolve("Hello"))
    .then(value => value + " from")
    .then(value => value + " chain")
    .then(value => value + " of")
    .then(value => value + " Promises")
    .then(finalValue => console.log(finalValue))
    .catch(error => console.log(error))
    .finally(() => console.log("End"));
```

### Функція Promise.all
Функція `Promise.all()` повертає єдиний об'єкт Promise, який поєднує набір промісів.

```javascript
const promise2 = new Promise((resolve, reject) => {
    setTimeout(resolve, 1000, "Hello");
});
const promise3 = new Promise((resolve, reject) => {
    setTimeout(resolve, 500, "World");
});
Promise.all([promise2, promise3]).then(values => {
    values.forEach((val) => {
        console.log(val);
    });
});
```
Тепер дані обох промісів повертаються разом і доступні у методі then() як масиву values. 

#
## Async та await

Впровадження стандарту `ES2017` у JavaScript привнесло два нових оператори: `async` та `await`, який покликані спростити роботу з промісами.

Оператор `async` визначає асинхронну функцію, в якій, як передбачається, виконуватиметься одне або кілька асинхронних завдань. Всередині асинхронної функції ми можемо застосувати оператор `await`. Він ставиться перед викликом асинхронної операції, яка є об'єктом `Promise`:

```javascript
function sum(x, y) {
    return new Promise((resolve) => {
        const result = x + y;
        setTimeout(() => {
            resolve(result);
        }, 1000);
    });
}

async function calculate() {
    const value1 = await sum(5, 3);
    console.log("Результат 1 асинхронної операції:", value1);
    const value2 = await sum(6, 4);
    console.log("Результат 2 асинхронної операції:", value2);
    const value3 = await sum(7, 5);
    console.log("Результат 3 асинхронної операції:", value3);
}

calculate();
//Результат 1 асинхронної операції: 8
//Результат 2 асинхронної операції: 10
//Результат 3 асинхронної операції: 12
```
### Обробка помилок
Для обробки помилок, які можуть виникнути в процесі виклику асинхронної операції, застосовується конструкція `try..catch..finally`.
